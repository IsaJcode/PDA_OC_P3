
1- Choix du labyrinthe:
Le labyrinthe est représenté par une chaîne de caractère dans le fichier level.
Les 0 seront interprétés comme des positions libres, les m comme des positions de briques

2- Utilisation de pygame:
Le module pygame est essentielement uliliser pour les fonctions d'affichages et de récupération des évènements clavier
Pour l'affichage,
On cree un objet fenetre et on utilise la methode blit .blit(image, position) pour afficher des images dans b
La technique d'affichage est d'empiler les images les unes au dessus des autres

3- Les Objets
Héritage

J'ai choisi d'utiliser des méthodes/attributs de classe pour les objet ramassés pour pouvoir avoir accès à tous les objets à partir de la classe

4- Position des objets au départ:
Position de McGyver à l'entrée du labyrinthe, Position du garde

Pour augmenté la rejouabilité, la position des objets au départ est alléatoire.
Pour obtenir ce résultat, j'utilise la méthode new_pos_elt de la class labi qui fournit une position libre du labyrinthe
en mettant à jour la liste de position libre dans le labyrinthe
C'est une méthode de la class labi par souci d'encapsulation en effet, on y manipule des attributs de Labi


5- Mouvements de McGyver:

Récupération du mouvement et méthode new_position :
La récupération des évènements clavier se fait par la classe event du module Pygame, 
On utilise la méthode new_position s'il s'agit de touche de déplacement utilisée,
cette méthode renvoie la position que l'utilisateur a l'intention de faire prendre à McGyver sur l'appui de la touche

McGyver utilise la méthode move qui: 
- utilise la méthode new_position pour calculer la nouvelle position de McGyver
- gère les collisions
- Met en place le resultat final dépendant du nombre d'objet ramassé



6- Gestion des collisions:

J'ai choisi d'utiliser des méthodes directement dans les objets heurtés par McGyver par
souci d'encapsulation. En effet ces objets prennent en entrées la position de McGyver et
manipule les attributs propres aux classes des objets heurtés.

collision_elt(cls, pos, i) => retourne si oui ou non un objet a été récuperé et traite la récuperation de l'objet


Les deux fonctions suivantes ne font pas de traitement parce que par souci d'encapsulation, c'est à la classe McGyver
de "déplacer" McGyver, d'afficher le resultat de la partie
collision_lab(self, pos) => retourne si oui ou McGyver peut se déplacer (pos est la position que veut prendre McGyver)
collision_garde(self, pos) => retourne si oui ou non McGyver a atteint le garde


7- Compteur d'objets ramassés:

Le nombre d'objet ramassé est enregistré par l'attribut NbElemtPick de McGyver il est modifié en fonction du retour de la méthode Element.collision_elt

8- Déroulement du jeu
La fonction principale utilisée pour le déroulement du jeu est la fonction routine,
elle est appelée lorsque l'évènement clavier est un appui sur une flèche de déplacement,
elle se charge de piloter les mouvements de McGyver et leurs conséquences
et de faire les affichages de la fenêtre et des objets

9- Fin de la partie:
La fin de la partie arrive quand la collision_garde retourne que McGyver a atteint le garde
à ce momment, la class result affichera le résultat définitif


10- Architecture du code

3 fichiers de constituent le jeu, 
level : qui renferme la représentation du labyrinthe en chaîne de caractère
team : qui renferme la définition de toutes les classes
initialise : qui renferme l'initialisation de toutes les classes
joue : fichier principal, fichier de lancement du jeu, qui lance/coupe le jeu et renferme la fonction routine

Un répertoire ressource pour toutes les images pour une meilleure visibilité dans les répertoires


11- Qualité du code
Pour founir un code de qualité, j'ai utilisé Pylint, j'ai une note de...
Et les erreurs restantes sont...


12- Partage du code
Pour le déploiement du jeu, j'ai crée un fichier requirements à partir d'un environnement virtuel, ce fichier peremettra à 
tous de mettre en place les modules peremettant le fonctionnemet du jeu

L'ensemble du code ainsi que le fichier requierement sont disponibles sur github


13- Difficultées rencontrées
Les principales difficultés que j'ai rencontré se trouvent au niveau :
- des ressources pygame... trouver une version de pygame compatible avec python 3
- créer un environnement virtuel, y installer pygame et créer le fichier requirement, la difficulté était qu'il fallait
trouver les bonnes lignes de commande, celles disponibles dans le cours ne sont que partiel, et les ressources sur internet
sont plus nombreuses pour linux que pour windows

14- Solutions trouvées
Beaucoup de recherche sur internet et test de lignes de commande.
